The mapping syntax is pure XML. It can easily be processed by any XML package in any language.
Although no API definition is part of the standard, the experience we got when exercising the syntax allows us to identify 
four processing levels.

\begin{enumerate} 
  \item Raw XML: The client resolves the reference and delivers an XML block corresponding to the searched models or model components. 
        The client must then extract the search elements by using XPath queries applied to the the MIVOT namespace.
  \item XML Wrapper class: The XPath strings mentioned above can be wrapped in generic objects providing 
        accessors retrieving model nodes by selecting types or roles. 
  \item Model classes: For the most popular models and especially for the models that provide reusable 
        components (Meas/Coord, PhotDM), the API can include objects instantiating model classes (e.g. Photometric filter).
  \item Automatic extraction of class instances of common frameworks: One of the goal of the data annotation is to 
        facilitate the connection between data and API code. This could be achieved with an API able to automatically 
        build objects from the annotated data without asking the user to infer on meta data. Taking the Astropy example, 
        a model-enable Python API should be able to build e.g. \texttt{Skycoord} instances in a transparent way and 
        feed them with \texttt{FIELD} values from \texttt{TABLE} rows or from \texttt{PARAM}.
 \end{enumerate}

Level 1 and 2 may only be useful for client developpers, they should be hidden to the end user. 
Using MIVOT annotations makes sense only if the client code provides 
the users with a direct access to both modeled quantities and links that connect them. 
MIVOT is a machine level system that relies primarily on higher level APIs to provide representations 
of the models (level 3 and 4) to end users

The first feature that a user-friendly API processing MIVOT annotations should implement is the ability 
to transparently build from the annotation, the objects usually exposed to the user. 
These objects could be extended to support features made 
possible by the annotations such as e.g. the parameter grouping or the connection with calibration data.
